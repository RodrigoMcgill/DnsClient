/*
 * @Author: Rodrigo M , Katwar Be
 * DNS client server
 * Network lab.................
 */

import java.io.BufferedReader;
import java.io.ByteArrayOutputStream;
import java.io.DataOutputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.InetAddress;
import java.net.SocketException;
import java.net.UnknownHostException;
import java.nio.ByteBuffer;
import java.util.Arrays;
import java.util.Random;

public class DnsClient {

	private static int port = 53;
	private static  byte [] receiveData = new byte[500];
	private static String timeOutValue;
	private static String maxRetriesValue;
	private static String typeQuerry;
	private static String IPAddress;
	private static String domain;
	private static boolean error = false;
	private static int maxUDPSize = 512; //bytes
	
	
	//Main method
	public static void main(String[] args) throws Exception {
		DnsClient dnsc = new DnsClient();
		dnsc.run(args);
	}
	
	
	public void run(String[] args) throws IOException{
    
		String inputUser = "";
			for(int arg = 0; arg < args.length; arg++){
				inputUser += args[arg] + " ";
			}
		
			if(inputUser == ""){
				System.out.println("No arguments provided");
				System.exit(0);
				}
			
			else{		
				acquiringParameters(inputUser); 
					//if in any of the previous methods, something went wrong that does not meet the format, then an error will occur and program will not continue
				}
		    
	}

	
	public static void acquiringParameters(String inputUser) throws IOException{
		
		inputCommandLine icl = new inputCommandLine();
		
		try{
			//extracts the time out value ,(optional) default: 5
			timeOutValue = icl.TimeOutInputMapping(inputUser);
			System.out.println("time out value " + timeOutValue);

			//extracts the max retries values, (optional) default: 3
			maxRetriesValue = icl.maxRetriesInputMapping(inputUser);
			System.out.println("max out value : " + maxRetriesValue);

			//extracts type of Querry (optional) default : Type A
			typeQuerry = icl.typeQuerryInputMapping(inputUser);
			System.out.println("type of Querry : " + typeQuerry);

			//extracts ip address (mandatory)
			IPAddress = icl.ipAddressInputMapping(inputUser)[0];
			System.out.println("ip address : " + IPAddress);

			//extracts host domain (mandatory)
			domain = icl.ipAddressInputMapping(inputUser)[1];
			System.out.println("name of website is : " + domain );
			
			}catch(Exception e){
				System.out.println("something went wrong in extrating the values");
				error = false;
		}
		
	    if(icl.getError()){
	    	error = true;
	    	System.out.println(icl.getMessageError());
	    	System.exit(0);
		}
	     else{
	     System.out.println("----checkpoint reached-----");
	     
	        //converts ip address into IP object
	        InetAddress ipAddress = InetAddress.getByName(IPAddress);

	        ByteArrayOutputStream baos = new ByteArrayOutputStream();
	        DataOutputStream dos = new DataOutputStream(baos);

	        // *** Build a DNS Request Frame ****

	        // Identifier: A 16-bit identification field generated by the device that creates the DNS query. 
	        // It is copied by the server into the response, so it can be used by that device to match that 
	        // query to the corresponding reply received from a DNS server. This is used in a manner similar 
	        // to how the Identifier field is used in many of the ICMP message types.
	        Random ranI = new Random();
	 		
			  
			 
		        short s = (short) ranI.nextInt(Short.MAX_VALUE + 1);
		       
		        System.out.println(s);
		     // id   
	        dos.writeShort(s);
	        

	        // Write Query Flags
	        dos.writeByte(0);
	        
	        dos.writeByte(0);

	         
	         
	         
	        // Question Count: Specifies the number of questions in the Question section of the message.
	        dos.writeShort(0x0001);
	        String s12 = String.format("%8s", Integer.toBinaryString(baos.size() & 0xFF)).replace(' ', '0');
			System.out.println(s12);
	        // Answer Record Count: Specifies the number of resource records in the Answer section of the message.
	        dos.writeShort(0x0000);

	        // Authority Record Count: Specifies the number of resource records in the Authority section of 
	        // the message. (“NS” stands for “name server”)
	        dos.writeShort(0x0000);

	        // Additional Record Count: Specifies the number of resource records in the Additional section of the message.
	        dos.writeShort(0x0000);

	        // TODO: write query
	        String[] domainParts = domain.split("\\.");
	        System.out.println(domain + " has " + domainParts.length + " parts");

	        for (int i = 0; i<domainParts.length; i++) {
	            System.out.println("Writing: " + domainParts[i]);
	            byte[] domainBytes = domainParts[i].getBytes("UTF-8");
	            dos.writeByte(domainBytes.length);
	            dos.write(domainBytes);
	        }

	        // No more parts
	        dos.writeByte(0x00);

	        // Type 0x01 = A (Host Request)
	        dos.writeShort(0x0001);

	        // Class 0x01 = IN
	        dos.writeShort(0x0001);

	        byte[] dnsFrame = baos.toByteArray();

	        System.out.println("Sending: " + dnsFrame.length + " bytes");
	        for (int i =0; i< dnsFrame.length; i++) {
	            System.out.print("0x" + String.format("%x", dnsFrame[i]) + " " );
	        }

	        // *** Send DNS Request Frame ***
	        DatagramSocket socket = new DatagramSocket();
	        DatagramPacket dnsReqPacket = new DatagramPacket(dnsFrame, dnsFrame.length, ipAddress, port);
	        socket.send(dnsReqPacket);

	        // Await response from DNS server
	        byte[] buf = new byte[1024];
	        DatagramPacket packet = new DatagramPacket(buf, buf.length);
	        System.out.println("!!!!Packet sent");
	        socket.receive(packet);
	        System.out.println("Response received!!!!!!");
	        
	     }
    }
	
	
}
					